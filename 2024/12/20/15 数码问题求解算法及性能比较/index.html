<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yang Mingxin"><meta name="keywords" content="blog"><meta name="description" content="15 数码问题求解算法及性能比较摘要本研究旨在探讨和比较不同求解算法及其启发式函数在解决 15 数码问题时的性能表现。15 数码问题是一个经典的益智游戏，涉及在一个 4x4 网格中通过移动方块达到有序布局。实验的核心是 A* 搜索算法，结合多种启发式函数（海明距离、棋盘距离、曼哈顿距离和欧几里得距离）进行性能评估。实验结果表明，曼哈顿距离和棋盘距离在求解时间和步数上表现优异，而海明距离则效率较低。"><meta property="og:type" content="article"><meta property="og:title" content="15数码问题求解算法及性能比较"><meta property="og:url" content="http://example.com/2024/12/20/15%20%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E7%AE%97%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/index.html"><meta property="og:site_name" content="Yang Mingxin&#39;s Blog"><meta property="og:description" content="15 数码问题求解算法及性能比较摘要本研究旨在探讨和比较不同求解算法及其启发式函数在解决 15 数码问题时的性能表现。15 数码问题是一个经典的益智游戏，涉及在一个 4x4 网格中通过移动方块达到有序布局。实验的核心是 A* 搜索算法，结合多种启发式函数（海明距离、棋盘距离、曼哈顿距离和欧几里得距离）进行性能评估。实验结果表明，曼哈顿距离和棋盘距离在求解时间和步数上表现优异，而海明距离则效率较低。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/Further509/Picture/main/image-20241216113926905.png"><meta property="article:published_time" content="2024-12-20T10:17:07.000Z"><meta property="article:modified_time" content="2024-12-20T10:19:35.698Z"><meta property="article:author" content="Yang Mingxin"><meta property="article:tag" content="AI"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://raw.githubusercontent.com/Further509/Picture/main/image-20241216113926905.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>15数码问题求解算法及性能比较 - Yang Mingxin&#39;s Blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"example.com",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yang Mingxin&#39;s Blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/indexsecond.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="15数码问题求解算法及性能比较"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-20 18:17" pubdate>2024年12月20日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 93 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">15数码问题求解算法及性能比较</h1><p class="note note-info">本文最后更新于：2024年12月20日 晚上</p><div class="markdown-body"><h1 id="15-数码问题求解算法及性能比较"><a href="#15-数码问题求解算法及性能比较" class="headerlink" title="15 数码问题求解算法及性能比较"></a>15 数码问题求解算法及性能比较</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本研究旨在探讨和比较不同求解算法及其启发式函数在解决 15 数码问题时的性能表现。15 数码问题是一个经典的益智游戏，涉及在一个 4x4 网格中通过移动方块达到有序布局。实验的核心是 A* 搜索算法，结合多种启发式函数（海明距离、棋盘距离、曼哈顿距离和欧几里得距离）进行性能评估。实验结果表明，曼哈顿距离和棋盘距离在求解时间和步数上表现优异，而海明距离则效率较低。研究还发现，问题的初始状态与目标状态之间的距离直接影响求解时间和步数。基于实验结果，提出改进建议，包括启发式函数的优化、算法适应性的增强以及并行计算的应用，以提升 15 数码问题求解算法的效率和适用性。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h2><p>15 数码问题是一个经典的益智游戏，起源于 19 世纪末。它由一个 4x4 的网格组成，包含 15 个标有数字的方块和一个空白位置。目标是通过移动方块（只能与空白位置相邻的方块交换位置）将初始的随机布局转变为有序的目标布局。这个问题不仅因其娱乐性而受到欢迎，也因其在计算机科学和人工智能领域的研究价值而备受关注。</p><p><img src="https://raw.githubusercontent.com/Further509/Picture/main/image-20241216113926905.png" srcset="/img/loading.gif" lazyload alt="15数码问题"></p><center>图1 15数码问题</center><p>15 数码问题的研究意义在于它提供了一个理想的平台来探索和比较不同的搜索算法和启发式函数。由于其状态空间巨大（<code>16!</code> 种可能的布局），但又足够小以允许在合理的时间内进行搜索，因此它成为了评估算法性能的理想测试案例。此外，15 数码问题的求解过程涉及到路径搜索、启发式评估和状态空间表示等关键技术，这些技术在许多其他领域（如机器人路径规划、游戏AI等）中也有广泛应用。</p><p>本实验的目的是研究和比较不同的求解方法在解决 15 数码问题时的性能表现。我们将实现并分析多种启发式搜索算法，特别是 A* 算法，并探讨不同启发式函数对算法性能的影响。实验内容包括：设计和实现 15 数码问题的状态表示方法、生成初始状态、实现搜索算法及其启发式函数，并通过实验案例来评估这些算法的效率和有效性。通过这些研究，我希望深入理解启发式搜索算法的工作原理及其在实际问题中的应用潜力。</p><h2 id="2-问题的表示和求解算法"><a href="#2-问题的表示和求解算法" class="headerlink" title="2. 问题的表示和求解算法"></a>2. 问题的表示和求解算法</h2><p><strong>15 数码问题的状态表示方法</strong></p><p>15 数码问题的状态表示是求解算法的基础。在一个 4x4 的网格中，有 15 个标有数字的方块和一个空白位置。状态表示需要捕捉每个方块的位置以及空白位置。以下是状态表示的详细方法：</p><ol><li><strong>字符串表示</strong>：<ul><li>使用一个长度为 16 的字符串来表示整个网格的状态。每个字符代表一个方块或空白位置。</li><li>数字方块用字符 ‘a’ 到 ‘p’ 表示，分别对应数字 0 到 15。</li><li>空白位置用特定字符（如 ‘a’）表示。</li></ul></li><li><strong>字符映射</strong>：<ul><li>使用一个映射表 <code>unordered_map&lt;int, char&gt; h</code> 将数字映射到字符，方便状态表示和处理。</li></ul></li><li><strong>目标状态</strong>：<ul><li>目标状态是一个特定的字符串，表示所有方块按顺序排列的状态（例如 “bcdefghijklmnop”）。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> ha[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;; <span class="hljs-comment">// 每个数字的目标位置映射 如0-&gt;15, 1-&gt;0</span><br><span class="hljs-type">int</span> num[<span class="hljs-number">16</span>];                      <span class="hljs-comment">// 初始状态，存储输入的 16 个数字</span><br></code></pre></td></tr></table></figure><p><strong>15 数码问题的求解算法</strong></p><p>求解 15 数码问题的核心是搜索算法和启发式函数的结合。以下是求解算法的详细描述：</p><ol><li><strong>搜索算法</strong>：<ul><li>使用 A* 搜索算法，这是一种启发式搜索算法，结合了最佳优先搜索和 Dijkstra 算法的特点。</li><li>A* 算法通过优先队列管理待搜索的状态，优先选择估价函数值最小的状态进行扩展。</li></ul></li><li><strong>启发式函数</strong>：<ul><li><strong>海明距离</strong> (<code>hamming_distance</code>)：计算当前状态与目标状态不同的块的数量。这个函数衡量的是有多少个方块不在正确的位置。</li><li><strong>棋盘距离</strong> (<code>chessboard_f</code>)：计算每个方块到其目标位置的最大单轴距离。</li><li><strong>曼哈顿距离</strong> (<code>manhattan_f</code>)：计算每个方块到其目标位置的曼哈顿距离之和。这个函数考虑了方块的行和列位置。</li><li><strong>欧几里得距离</strong> (<code>euclidean_f</code>)：计算每个方块到其目标位置的欧几里得距离之和。这个函数考虑了方块的直线距离。</li></ul></li><li><strong>状态扩展</strong>：<ul><li>在搜索过程中，每个状态通过移动空白位置的相邻方块进行扩展，生成新的状态。</li><li>每个新状态的估价函数值由启发式函数计算，并根据这个值决定其在优先队列中的位置。</li></ul></li><li><strong>路径回溯</strong>：<ul><li>通过记录每个状态的前驱状态，实现路径回溯。一旦找到目标状态，就可以通过回溯前驱状态来重建解路径。</li></ul></li><li><strong>可解性判断</strong>：<ul><li>在开始搜索之前，通过计算逆序数和空格位置来判断初始状态是否有解。这一步确保了搜索不会在无解的状态上浪费资源。</li></ul></li></ol><p>通过上述状态表示和求解算法的设计，15 数码问题的求解过程被有效地组织和优化。A* 算法结合多种启发式函数，能够在合理的时间内找到问题的解。</p><h2 id="3-实验设计"><a href="#3-实验设计" class="headerlink" title="3. 实验设计"></a>3. 实验设计</h2><p><strong>实验目标</strong></p><p>实验的主要目标是研究和比较不同求解算法在解决 15 数码问题时的性能表现。具体目标包括：</p><ol><li><strong>算法性能评估</strong>：通过实验评估不同搜索算法及其启发式函数在解决 15 数码问题时的效率和有效性。</li><li><strong>启发式函数比较</strong>：比较不同启发式函数（如海明距离、曼哈顿距离、欧几里得距离）对 A* 算法性能的影响。</li><li><strong>问题难度分析</strong>：通过设计不同难度级别的 15 数码问题实例，分析算法在不同难度下的表现。</li><li><strong>可视化展示</strong>：以可视化方式呈现搜索过程，帮助理解算法的工作原理和性能差异。</li></ol><p><strong>评价指标</strong></p><p>为了全面评估算法性能，实验采用以下评价指标：</p><ol><li><strong>求解时间</strong>：记录算法找到解决方案所需的时间。这是衡量算法效率的关键指标。</li><li><strong>步数</strong>：记录从初始状态到目标状态所需的最少移动步数。这是衡量算法有效性的重要指标。</li></ol><p><strong>设计难度不同的 15 数码问题实例</strong></p><p>下面给出16种不同的样例（总体难度递增）</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs txt">5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12<br>5 1 2 3 0 6 8 4 9 10 7 11 13 14 15 12<br>5 1 3 4 2 0 7 8 10 6 11 12 9 13 14 15<br>1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15<br>1 2 3 0 5 6 7 4 9 10 11 8 13 14 15 12<br>0 1 2 3 5 6 7 4 9 10 11 8 13 14 15 12<br>1 2 3 4 5 6 7 8 9 10 11 12 13 0 14 15<br>1 2 3 4 5 6 7 8 9 10 11 12 0 13 14 15<br>5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12<br>1 2 6 4 5 10 11 8 13 9 15 0 7 12 3 14<br>1 2 3 4 5 10 6 8 0 9 7 12 13 14 11 15<br>2 5 1 3 7 11 6 4 10 14 9 8 13 0 12 15<br>5 3 7 8 1 2 11 4 13 6 15 14 0 10 9 12<br>11 9 4 15 1 3 0 12 7 5 8 6 13 2 10 14<br>0 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1<br>1 3 5 7 9 11 13 15 2 4 6 8 10 12 14 0<br></code></pre></td></tr></table></figure><p><strong>选择并实现不同的搜索算法</strong></p><p>本实验采用A*算法，通过更换不同的启发函数来对比不同启发函数下算法的有效性和效率。</p><ul><li>海明距离</li><li>棋盘距离</li><li>曼哈顿距离</li><li>欧几里得距离</li></ul><h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4. 实验结果"></a>4. 实验结果</h2><p>选取了六种难易不同的初始状态进行在不同启发函数下的对比实验，结果如下表所示：</p><center>表1 不同样例在不同方法下的求解结果(TLE表示超出规定求解时间)</center><table><thead><tr><th align="center">初始状态</th><th align="left">A* (海明距离)</th><th>A* (棋盘距离)</th><th align="left">A* (曼哈顿距离)</th><th align="left">A* (欧几里得距离)</th></tr></thead><tbody><tr><td align="center">5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12</td><td align="left">TLE</td><td>时间：0.000188218秒，步数：15</td><td align="left">时间：0.000174202秒，步数：15</td><td align="left">时间：0.000294349秒，步数：15</td></tr><tr><td align="center">1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15</td><td align="left">TLE</td><td>时间：3.4887e-05秒，步数：5</td><td align="left">时间：4.0557e-05秒，步数：5</td><td align="left">时间：5.268e-05秒，步数：5</td></tr><tr><td align="center">1 2 3 4 5 6 7 8 9 10 11 12 0 13 14 15</td><td align="left">TLE</td><td>时间：1.9928e-05秒，步数：3</td><td align="left">时间：3.0228e-05秒，步数：3</td><td align="left">时间：3.3814e-05秒，步数：3</td></tr><tr><td align="center">2 5 1 3 7 11 6 4 10 14 9 8 13 0 12 15</td><td align="left">TLE</td><td>时间：1.85473秒，步数：32</td><td align="left">时间：0.182626秒，步数：32</td><td align="left">时间：2.17753秒，步数：32</td></tr><tr><td align="center">5 3 7 8 1 2 11 4 13 6 15 14 0 10 9 12</td><td align="left">TLE</td><td>时间：76.0207秒，步数：39</td><td align="left">时间：3.7021秒，步数：39</td><td align="left">时间：84.4167秒，步数：39</td></tr><tr><td align="center">11 9 4 15 1 3 0 12 7 5 8 6 13 2 10 14</td><td align="left">TLE</td><td>时间：16.3697秒，步数：41</td><td align="left">时间：0.108953秒，步数：41</td><td align="left">时间：18.5989秒，步数：41</td></tr></tbody></table><p>从表中可以发现，海明距离作为启发函数的A*算法求解效率极低，在规定时间基本无法求解出正确结果。而棋盘距离，曼哈顿距离和欧几里得距离均可求得正确答案。但其中曼哈顿距离的优势较为明显，求解速度很快，在困难的任务中尤其突出。</p><h2 id="5-实验分析与讨论"><a href="#5-实验分析与讨论" class="headerlink" title="5. 实验分析与讨论"></a>5. 实验分析与讨论</h2><p>通过上述实验，可以得出以下结论：</p><ol><li><strong>海明距离的局限性</strong>：<ul><li>在所有测试案例中，使用海明距离作为启发函数的 A* 算法均未能在合理时间内找到解决方案。这表明海明距离在这种类型的问题中可能不够有效，因为它没有充分利用方块位置的具体信息。</li></ul></li><li><strong>棋盘距离的优势</strong>：<ul><li>棋盘距离在大多数情况下表现出了较好的性能，尤其是在较难的实例中（如第四个和第五个示例）。它通常能够在较短的时间内找到解决方案，尽管在某些情况下步数可能较多。</li></ul></li><li><strong>曼哈顿距离的稳定性</strong>：<ul><li>曼哈顿距离在所有测试案例中均表现出稳定的性能，提供了较好的时间效率和步数。它在处理不同难度的实例时都能保持较好的表现，显示出其作为启发函数的可靠性。</li></ul></li><li><strong>欧几里得距离的效率</strong>：<ul><li>欧几里得距离在某些情况下（如第一个和第三个示例）提供了最快的求解时间，但在其他更复杂的实例中可能不如棋盘距离或曼哈顿距离有效。这表明欧几里得距离在某些特定情况下可能更优。</li></ul></li></ol><p><strong>可视化分析：</strong></p><p>在求解过程通过打印棋盘状态来进行过程的可视化分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 输出棋盘的函数，将状态字符串输出为 4x4 格局</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_board</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">int</span>(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 每4个数换行</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如选取初始状态<code>1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15</code>，运行结果如下</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs txt">1 0 3 4 <br>5 2 7 8 <br>9 6 11 12 <br>13 10 14 15 <br><br>1 2 3 4 <br>5 0 7 8 <br>9 6 11 12 <br>13 10 14 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 0 11 12 <br>13 10 14 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 10 11 12 <br>13 0 14 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 10 11 12 <br>13 14 0 15 <br><br>1 2 3 4 <br>5 6 7 8 <br>9 10 11 12 <br>13 14 15 0 <br><br>Time taken: 5.4303e-05 seconds<br>Steps: 5<br>DDDRR<br></code></pre></td></tr></table></figure><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><p>通过对 15 数码问题的多种求解算法及其启发式函数的实验比较，我们得出以下结论：</p><ol><li><strong>启发式函数的重要性</strong>：<ul><li>启发式函数的选择对 A* 算法的性能有显著影响。曼哈顿距离和棋盘距离通常提供了较好的性能，而海明距离在这种情况下可能不够有效。</li></ul></li><li><strong>算法效率的差异</strong>：<ul><li>A* 算法结合适当的启发式函数（如曼哈顿距离和棋盘距离）在求解时间和步数上表现优异，尤其是在处理较难的实例时。</li></ul></li><li><strong>问题难度的影响</strong>：<ul><li>初始状态与目标状态之间的距离（如逆序数）直接影响求解时间和步数。更复杂的问题需要更高效的启发式函数来指导搜索。</li></ul></li></ol><p><strong>改进建议</strong></p><p>基于实验结果，提出以下对改进 15 数码问题求解算法的思考和建议：</p><ol><li><strong>启发式函数的优化</strong>：<ul><li>继续研究和开发更高效的启发式函数，以进一步提高 A* 算法的性能。可以考虑结合多种启发式函数的优点，设计新的复合启发式函数。</li></ul></li><li><strong>算法的适应性</strong>：<ul><li>改进算法以适应不同难度的问题。对于更复杂的问题，可以考虑使用更高级的搜索策略，如迭代深化搜索或双向搜索。</li></ul></li><li><strong>并行计算的应用</strong>：<ul><li>利用并行计算技术来加速搜索过程。通过多线程或分布式计算，可以同时探索多个搜索路径，从而提高求解速度。</li></ul></li><li><strong>算法的泛化能力</strong>：<ul><li>研究算法在其他类似问题（如更大规模的数码问题）中的应用潜力，以验证其泛化能力。</li></ul></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1] Johnson, W. W., &amp; Story, W. E. (1879). Notes on the “15” puzzle. <em>American Journal of Mathematics</em>, <em>2</em>(4), 397-404.</p><p>[2] Story, W. E. (1879). Notes on the” 15” Puzzle. <em>American Journal of Mathematics</em>, <em>2</em>(4), 397-404.</p><p>[3] Culberson, J., &amp; Schaeffer, J. (1994). Efficiently searching the 15-puzzle.</p><p>[4] Tang, G., Tang, C., Claramunt, C., Hu, X., &amp; Zhou, P. (2021). Geometric A-star algorithm: An improved A-star algorithm for AGV path planning in a port environment. <em>IEEE access</em>, <em>9</em>, 59196-59210.</p><p>[5] Erke, S., Bin, D., Yiming, N., Qi, Z., Liang, X., &amp; Dawei, Z. (2020). An improved A-Star based path planning algorithm for autonomous land vehicles. <em>International Journal of Advanced Robotic Systems</em>, <em>17</em>(5), 1729881420962263.</p><p>[6] <a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/a-search-algorithm/">https://www.geeksforgeeks.org/a-search-algorithm/</a></p><p>[7] <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/15_puzzle">https://en.wikipedia.org/wiki/15_puzzle</a></p><p>[8] <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44174803/article/details/109901611">https://blog.csdn.net/qq_44174803/article/details/109901611</a></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><code>astar.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span> <span class="hljs-comment">// 用于计时</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; h;                <span class="hljs-comment">// 数字到字符的映射（方便状态表示）</span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; dist;           <span class="hljs-comment">// 当前状态的步数</span><br>unordered_map&lt;string, string&gt; pre;         <span class="hljs-comment">// 当前状态的前一个状态，用于路径回溯</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, string&gt; PIS;             <span class="hljs-comment">// 优先队列元素：估价函数值和状态字符串</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><br><span class="hljs-type">int</span> ha[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>&#125;; <span class="hljs-comment">// 每个数字的目标位置映射 如0-&gt;15, 1-&gt;0</span><br><span class="hljs-type">int</span> num[<span class="hljs-number">16</span>];                      <span class="hljs-comment">// 初始状态，存储输入的 16 个数字</span><br><br><span class="hljs-comment">// 海明距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hamming_distance</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[i] != h[i]) &#123;  <span class="hljs-comment">// 如果当前块不等于目标位置的块</span><br>            cnt++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 棋盘距离作为启发函数，计算状态字符串到目标状态的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chessboard_f</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-type">int</span> p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;       <span class="hljs-comment">// 将字符映射回数字</span><br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">continue</span>;         <span class="hljs-comment">// &#x27;a&#x27; 表示空格，跳过</span><br>        <span class="hljs-type">int</span> sx = i % <span class="hljs-number">4</span>, sy = i / <span class="hljs-number">4</span>;                <span class="hljs-comment">// 当前数字位置的坐标</span><br>        <span class="hljs-type">int</span> tx = ha[p] % <span class="hljs-number">4</span>, ty = ha[p] / <span class="hljs-number">4</span>;      <span class="hljs-comment">// 目标位置坐标</span><br>        cnt += <span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(sx - tx), <span class="hljs-built_in">abs</span>(sy - ty));  <span class="hljs-comment">// 棋盘距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 曼哈顿距离作为启发函数，计算状态字符串到目标状态的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">manhattan_f</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-type">int</span> p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;       <span class="hljs-comment">// 将字符映射回数字</span><br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">continue</span>;         <span class="hljs-comment">// &#x27;a&#x27; 表示空格，跳过</span><br>        <span class="hljs-type">int</span> sx = i % <span class="hljs-number">4</span>, sy = i / <span class="hljs-number">4</span>;                <span class="hljs-comment">// 当前数字位置的坐标</span><br>        cnt += <span class="hljs-built_in">abs</span>(sx - ha[p] % <span class="hljs-number">4</span>) + <span class="hljs-built_in">abs</span>(sy - ha[p] / <span class="hljs-number">4</span>); <span class="hljs-comment">// 曼哈顿距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 欧几里得距离作为启发函数，计算状态字符串到目标状态的距离</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">euclidean_f</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-type">int</span> p = s[i] - <span class="hljs-string">&#x27;a&#x27;</span>;       <span class="hljs-comment">// 将字符映射回数字</span><br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">continue</span>;         <span class="hljs-comment">// &#x27;a&#x27; 表示空格，跳过</span><br>        <span class="hljs-type">int</span> sx = i % <span class="hljs-number">4</span>, sy = i / <span class="hljs-number">4</span>;                <span class="hljs-comment">// 当前数字位置的坐标</span><br>        <span class="hljs-type">int</span> tx = ha[p] % <span class="hljs-number">4</span>, ty = ha[p] / <span class="hljs-number">4</span>;      <span class="hljs-comment">// 目标位置坐标</span><br>        cnt += <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(sx - tx, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(sy - ty, <span class="hljs-number">2</span>));  <span class="hljs-comment">// 欧几里得距离</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">// 判断数码问题是否有解，通过计算逆序数和空格位置校验</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">solvable</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!num[i]) cnt += <span class="hljs-number">3</span> - i / <span class="hljs-number">4</span>;  <span class="hljs-comment">// 空格所在行到目标状态行的距离</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (num[j] &amp;&amp; num[j] &gt; num[i]) cnt++;  <span class="hljs-comment">// 计算逆序数</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <span class="hljs-comment">// 可解当且仅当逆序数为偶数</span><br>&#125;<br><br><span class="hljs-comment">// 输出棋盘的函数，将状态字符串输出为 4x4 格局</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_board</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">int</span>(s[i]-<span class="hljs-string">&#x27;a&#x27;</span>) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 每4个数换行</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// A* 搜索主算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Astar</span><span class="hljs-params">(string sta, <span class="hljs-type">int</span> (*f)(string))</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> start_time = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); <span class="hljs-comment">// 开始计时</span><br>    priority_queue&lt;PIS, vector&lt;PIS&gt;, greater&lt;PIS&gt;&gt; q; <span class="hljs-comment">// 小顶堆，按估价函数排序</span><br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">f</span>(sta), sta&#125;);                           <span class="hljs-comment">// 初始状态入队</span><br>    dist[sta] = <span class="hljs-number">0</span>;                                   <span class="hljs-comment">// 初始状态步数为 0</span><br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        string s = t.y;<br>        <span class="hljs-type">int</span> step = t.x;<br><br>        <span class="hljs-comment">// 输出每一步的棋盘矩阵，计时时注释掉，减少IO时间</span><br>        <span class="hljs-comment">// print_board(s);</span><br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">f</span>(s) &amp;&amp; dist[s] &lt;= <span class="hljs-number">45</span>) &#123;<br>            <span class="hljs-keyword">auto</span> end_time = chrono::high_resolution_clock::<span class="hljs-built_in">now</span>(); <span class="hljs-comment">// 结束计时</span><br>            chrono::duration&lt;<span class="hljs-type">double</span>&gt; elapsed = end_time - start_time;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Time taken: &quot;</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; seconds\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> dist[s]; <span class="hljs-comment">// 找到目标状态</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (step &gt; <span class="hljs-number">45</span>) <span class="hljs-keyword">break</span>;                      <span class="hljs-comment">// 超过搜索步数限制，认为无解</span><br><br>        <span class="hljs-type">int</span> zero;                                  <span class="hljs-comment">// 记录空格位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                zero = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 四个方向的状态转移</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; directions = &#123;<span class="hljs-number">-4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;;   <span class="hljs-comment">// 上下左右</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : directions) &#123;<br>            <span class="hljs-type">int</span> newZero = zero + d;<br>            <span class="hljs-keyword">if</span> (newZero &lt; <span class="hljs-number">0</span> || newZero &gt;= <span class="hljs-number">16</span>) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">// 越界检测</span><br>            <span class="hljs-keyword">if</span> ((zero % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; d == <span class="hljs-number">-1</span>) || ((zero + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; d == <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 水平越界检测</span><br><br>            string ss = s;<br>            <span class="hljs-built_in">swap</span>(ss[zero], ss[newZero]);                   <span class="hljs-comment">// 交换空格和目标位置</span><br>            <span class="hljs-keyword">if</span> (!dist.<span class="hljs-built_in">count</span>(ss) &amp;&amp; ss != sta) &#123;            <span class="hljs-comment">// 新状态未被访问过</span><br>                dist[ss] = dist[s] + <span class="hljs-number">1</span>;                    <span class="hljs-comment">// 更新步数</span><br>                q.<span class="hljs-built_in">push</span>(&#123;dist[ss] + <span class="hljs-built_in">f</span>(ss), ss&#125;);            <span class="hljs-comment">// 入队</span><br>                pre[ss] = s;                               <span class="hljs-comment">// 记录前驱状态</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 搜索失败，返回无解</span><br>&#125;<br><br><span class="hljs-comment">// 根据两个状态的空格位置，返回操作方向</span><br><span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">check</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> d1, d2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            d1 = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">size</span>(); i++)<br>        <span class="hljs-keyword">if</span> (b[i] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>            d2 = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span> (d1 - <span class="hljs-number">4</span> == d2) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;U&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (d1 == d2 - <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (d1 - <span class="hljs-number">1</span> == d2) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;L&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (d1 + <span class="hljs-number">1</span> == d2) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;R&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;?&#x27;</span>; <span class="hljs-comment">// 不应发生</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">15</span>; i++) h[i] = <span class="hljs-string">&#x27;a&#x27;</span> + i; <span class="hljs-comment">// 初始化字符映射</span><br><br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        string s;<br>        dist.<span class="hljs-built_in">clear</span>();<br>        pre.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>            cin &gt;&gt; x;<br>            num[i] = x;<br>            s += h[x];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">solvable</span>()) &#123;  <span class="hljs-comment">// 判断是否有解</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;This puzzle is not solvable.\n&quot;</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">Astar</span>(s, chessboard_f); <span class="hljs-comment">// 启发函数</span><br>        <span class="hljs-keyword">if</span> (res == <span class="hljs-number">-1</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No answer for search&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Steps: &quot;</span> &lt;&lt; res &lt;&lt; endl;<br><br>        <span class="hljs-comment">// 回溯找到解路径</span><br>        string ss = <span class="hljs-string">&quot;bcdefghijklmnopa&quot;</span>, ans;<br>        <span class="hljs-keyword">while</span> (ss != s) &#123;  <br>            string sss = pre[ss];<br>            ans += <span class="hljs-built_in">check</span>(sss, ss);<br>            ss = sss;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) cout &lt;&lt; ans[i]; <span class="hljs-comment">// 逆序输出路径</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><center>表1 不同样例在不同方法下的求解结果(TLE表示超出规定求解时间)</center><table><thead><tr><th align="center">初始状态</th><th align="left">A* (海明距离)</th><th>A* (棋盘距离)</th><th align="left">A* (曼哈顿距离)</th><th align="left">A* (欧几里得距离)</th></tr></thead><tbody><tr><td align="center">5 1 2 4 9 6 3 8 13 15 10 11 0 14 7 12</td><td align="left">TLE</td><td>时间：0.000188218秒，步数：15</td><td align="left">时间：0.000174202秒，步数：15</td><td align="left">时间：0.000294349秒，步数：15</td></tr><tr><td align="center">1 0 3 4 5 2 7 8 9 6 11 12 13 10 14 15</td><td align="left">TLE</td><td>时间：3.4887e-05秒，步数：5</td><td align="left">时间：4.0557e-05秒，步数：5</td><td align="left">时间：5.268e-05秒，步数：5</td></tr><tr><td align="center">1 2 3 4 5 6 7 8 9 10 11 12 0 13 14 15</td><td align="left">TLE</td><td>时间：1.9928e-05秒，步数：3</td><td align="left">时间：3.0228e-05秒，步数：3</td><td align="left">时间：3.3814e-05秒，步数：3</td></tr><tr><td align="center">2 5 1 3 7 11 6 4 10 14 9 8 13 0 12 15</td><td align="left">TLE</td><td>时间：1.85473秒，步数：32</td><td align="left">时间：0.182626秒，步数：32</td><td align="left">时间：2.17753秒，步数：32</td></tr><tr><td align="center">5 3 7 8 1 2 11 4 13 6 15 14 0 10 9 12</td><td align="left">TLE</td><td>时间：76.0207秒，步数：39</td><td align="left">时间：3.7021秒，步数：39</td><td align="left">时间：84.4167秒，步数：39</td></tr><tr><td align="center">11 9 4 15 1 3 0 12 7 5 8 6 13 2 10 14</td><td align="left">TLE</td><td>时间：16.3697秒，步数：41</td><td align="left">时间：0.108953秒，步数：41</td><td align="left">时间：18.5989秒，步数：41</td></tr></tbody></table></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/AI/" class="category-chain-item">AI</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/AI/">#AI</a></div></div><div class="license-box my-3"><div class="license-title"><div>15数码问题求解算法及性能比较</div><div>http://example.com/2024/12/20/15 数码问题求解算法及性能比较/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Yang Mingxin</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月20日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/12/28/HUST-Annual-Eat/" title="HUST校园卡消费年终总结"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">HUST校园卡消费年终总结</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/12/10/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91-%E5%AE%9E%E4%BD%93%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E2%80%94%E2%80%94%E4%BC%81%E4%B8%9A%E6%95%B0%E6%8D%AE%E8%A7%86%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80/" title="论文翻译- 实体关系模型——企业数据视图的基础"><span class="hidden-mobile">论文翻译- 实体关系模型——企业数据视图的基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>